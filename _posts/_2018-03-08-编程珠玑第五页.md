复习《编程珠玑》第二版

对于P5页的理解：

1. 书中第三个图下部所说：于是问题就归结为是否能够用大约800万个可用位来表示1000万个互异的整数。

解释：由于1M是（1024 * 1024 * 8 = 8,388,608位bit），所以用800万个可用位表示1000万互异的整数。

2. 位图：位图的每一个元素都可表示一种或少量的状态，所处的位置又可以表示自身是第几个数。
3. 向量表：



用程序实现如何用1M内存查找1000万以内的数？

步骤：

​	1，生成一个1000万个bit的二进制文件（位图文件），将所有的bit全置为0；

​	2，生成700万个随机整数，将所有的整数对应的bit位置从0置为1；

​	3，编写查找函数，查看这个数是否大于5000001。小于5000001者把位图文件的前半部分读入内存中，大于者读后半部分。

​	4，最后查找对应位置的bit值：1存在，0不存在。

源代码解释：

1，bitmap[i >> SHIFT] ，将数字i / 32，得到i在bitmap中的位置index

2，(i & MASK)，将数字i 与 11111 操作，得到i在index中二进制列表中的位置

3，vector[i >> SHIFT] |= (1 << (i & MASK))，将i在向量中的对应位置的数置1

4，vector[i >> SHIFT] &= ~(1 << (i & MASK))，将i在向量中的对应位置的数置0



习题3，如何生成位于0到n-1之间的k个不同的随机顺序的随机整数。

用0填充N个一维向量，每个生成的随机数查对向量中对应的位置是否为1来判断随机数是否存在。



习题5，如果1M空间是严格的边界，推荐的算法时间复杂度？

由于一千万个bit占用约1.2M内存，所以无法一次性将文件读取到内存中。可将一千万折半存储，每次查找前检查数字是否在五百万之前或之后，以此判断加载哪个文件，所以时间复杂度为2。



习题6，在这一千万个整数中，最多可出现10次，如何得到对应的时间和空间复杂度？

由于2^4=16，所以可用4位bit来记录整数出现的次数。对应的空间将增加4倍，等于4.8M内存空间。



习题9，在空间很廉价，但时间非常宝贵且向量很稀疏的情况下，如何提供解决方案？

申请一个位向量，同时申请一个数组。位向量用于查找数值的个数，而且数组用于记录数值是否初始化。



习题10，如何组织数据库主键的插入和检索？

用二叉树，数字小的在左边，数字大的在右边。



习题11，解决每天汽车花费100美元来传输CAD图纸？

用两马相对或相反运动。



